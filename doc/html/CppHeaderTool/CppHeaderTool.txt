-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on GitHub at
--   <a>https://github.com/githubuser/SchmixEngineHeaderTool#readme</a>
@package CppHeaderTool
@version 0.1.0.0

module LexerTypes
type Lexer = Parsec Void String
data CppToken
Preprocessor :: CppToken
Whitespace :: CppToken
Comment :: String -> CppToken
Keyword :: String -> CppToken
Punctuator :: Char -> CppToken
Tag :: String -> CppToken
Identifier :: String -> CppToken
Digit :: Int -> CppToken
instance GHC.Classes.Eq LexerTypes.CppToken
instance GHC.Classes.Ord LexerTypes.CppToken
instance GHC.Show.Show LexerTypes.CppToken
instance Text.Megaparsec.Stream.VisualStream [LexerTypes.CppToken]

module Constants
punctuators :: [Char]
keywords :: [String]

module ParserTypes
type Parser = Parsec Void [CppToken]
type CppAttributeSpecifier = [CppToken]
data CppAccessSpecifier
Public :: CppAccessSpecifier
Private :: CppAccessSpecifier
Protected :: CppAccessSpecifier
data CppTypeSpecifier
CppTypeSpecifier :: String -> [CppAttributeSpecifier] -> CppTypeSpecifier
[typeSpecifierName] :: CppTypeSpecifier -> String
[typeAttributeSpecifiers] :: CppTypeSpecifier -> [CppAttributeSpecifier]
data CppEnumHead
CppEnumHead :: [CppAttributeSpecifier] -> String -> [CppTypeSpecifier] -> CppEnumHead
[enumAttributeSpecifiers] :: CppEnumHead -> [CppAttributeSpecifier]
[enumHeadName] :: CppEnumHead -> String
[enumBaseClause] :: CppEnumHead -> [CppTypeSpecifier]
data CppBaseSpecifier
CppBaseSpecifier :: String -> CppAccessSpecifier -> [CppAttributeSpecifier] -> Bool -> CppBaseSpecifier
[baseTypeSpecifier] :: CppBaseSpecifier -> String
[baseAccessSpecifier] :: CppBaseSpecifier -> CppAccessSpecifier
[baseAttributeSpecifiers] :: CppBaseSpecifier -> [CppAttributeSpecifier]
[isBaseVirtual] :: CppBaseSpecifier -> Bool
data CppClassHead
CppClassHead :: [CppAttributeSpecifier] -> String -> Bool -> [CppBaseSpecifier] -> CppClassHead
[classAttributeSpecifiers] :: CppClassHead -> [CppAttributeSpecifier]
[classHeadName] :: CppClassHead -> String
[isClassFinal] :: CppClassHead -> Bool
[classBaseClause] :: CppClassHead -> [CppBaseSpecifier]
data CppVariableDeclaration
CppVariableDeclaration :: String -> String -> [CppToken] -> [CppAttributeSpecifier] -> CppVariableDeclaration
[variableName] :: CppVariableDeclaration -> String
[variableType] :: CppVariableDeclaration -> String
[variableDeclSpecifiers] :: CppVariableDeclaration -> [CppToken]
[variableAttributeSpecifiers] :: CppVariableDeclaration -> [CppAttributeSpecifier]
class CppAstNode a
getChildren :: CppAstNode a => a -> [a]
setChildren :: CppAstNode a => a -> [a] -> a
class CppAstNode a => CppHeader a
makeHeader :: CppHeader a => [a] -> a
class CppAstNode a => CppNamespace a
makeNamespace :: CppNamespace a => String -> [a] -> a
getNamespaceName :: CppNamespace a => a -> Maybe String
class CppAstNode a => CppEnum a
makeEnum :: CppEnum a => CppEnumHead -> [a] -> a
getEnumInfo :: CppEnum a => a -> Maybe CppEnumHead
class CppAstNode a => CppClass a
makeClass :: CppClass a => CppClassHead -> [a] -> a
getClassInfo :: CppClass a => a -> Maybe CppClassHead
class CppAstNode a => CppEnumerator a
makeEnumerator :: CppEnumerator a => String -> [CppToken] -> a
getEnumeratorName :: CppEnumerator a => a -> Maybe String
getEnumeratorPostEqTokens :: CppEnumerator a => a -> Maybe [CppToken]
class CppAstNode a => CppMemberVariable a
makeMemberVariable :: CppMemberVariable a => CppVariableDeclaration -> a
getMemberVariableDeclaration :: CppMemberVariable a => a -> Maybe CppVariableDeclaration
instance GHC.Show.Show ParserTypes.CppAccessSpecifier
instance GHC.Show.Show ParserTypes.CppBaseSpecifier
instance GHC.Show.Show ParserTypes.CppClassHead
instance GHC.Show.Show ParserTypes.CppEnumHead
instance GHC.Show.Show ParserTypes.CppTypeSpecifier
instance GHC.Show.Show ParserTypes.CppVariableDeclaration

module Config
newtype ParserGraph a
ParserGraph :: Map ParserInjectionPoint [ParserGraph a -> Parser a] -> ParserGraph a
[parserGraph] :: ParserGraph a -> Map ParserInjectionPoint [ParserGraph a -> Parser a]
data ParserInjectionPoint
Global :: ParserInjectionPoint
InjectAt :: String -> ParserInjectionPoint
data ParserConfig a
ParserConfig :: String -> (String -> ParserGraph a -> Parser a) -> Set ParserInjectionPoint -> ParserConfig a
[parserName] :: ParserConfig a -> String
[parser] :: ParserConfig a -> String -> ParserGraph a -> Parser a
[parserInjectionPoints] :: ParserConfig a -> Set ParserInjectionPoint
data Config a
Config :: Set String -> Set (ParserConfig a) -> Config a
[tags] :: Config a -> Set String
[parsers] :: Config a -> Set (ParserConfig a)
makeParserGraph :: Set (ParserConfig a) -> ParserGraph a
addToParserGraph :: ParserConfig a -> ParserGraph a -> ParserGraph a
getParsers :: ParserInjectionPoint -> ParserGraph a -> [Parser a]
instance GHC.Classes.Eq (Config.ParserConfig a)
instance GHC.Classes.Eq Config.ParserInjectionPoint
instance GHC.Classes.Ord (Config.ParserConfig a)
instance GHC.Classes.Ord Config.ParserInjectionPoint
instance GHC.Show.Show Config.ParserInjectionPoint

module Util
applyParsers :: forall {m} {e} {s} {a}. MonadParsec e s m => [m a] -> m a
applyParsersUntil :: (Ord a, Stream b) => [Parsec a b c] -> Parsec a b d -> Parsec a b [c]
applyParsersUntil' :: (Ord a, Stream b) => [Parsec a b c] -> Parsec a b d -> Parsec a b [c]
(>>|) :: (Ord a, Stream b) => [Parsec a b c] -> Parsec a b d -> Parsec a b [c]
(>>|*) :: (Ord a, Stream b) => [Parsec a b c] -> Parsec a b d -> Parsec a b [c]
consumeTill :: forall {m} {e} {s} {end}. MonadParsec e s m => m end -> m [Token s]

module Parser
parseHeader :: CppHeader a => ParserGraph a -> Parser a
buildAst :: CppHeader a => ParserGraph a -> [CppToken] -> String -> Either (ParseErrorBundle [CppToken] Void) a
tokenToString :: CppToken -> String
tokensToString :: [CppToken] -> String
punctuator :: Char -> Parser Char
keyword :: String -> Parser String
identifier :: Parser String
tag :: String -> Parser String
matchIdentifier :: String -> Parser String
qualifiedName :: Parser String

-- | BNF Grammar:
--   
--   <pre>
--   namespace-definition:	 
--    	named-namespace-definition
--    	unnamed-namespace-definition
--   </pre>
--   
--   See <a>https://alx71hub.github.io/hcb/#namespace.def</a> for more
--   context
namespaceDefinition :: CppNamespace a => String -> ParserGraph a -> Parser a

-- | BNF Grammar:
--   
--   <pre>
--   named-namespace-definition:	 
--    	original-namespace-definition
--    	extension-namespace-definition
--   
--   original-namespace-definition:	 
--    	inline (opt) namespace identifier { namespace-body }
--   
--   extension-namespace-definition:	 
--    	inline (opt) namespace original-namespace-name { namespace-body }
--   </pre>
--   
--   Notes:
--   
--   <ul>
--   <li><tt> original-namespace-name </tt> = <tt> identifier </tt></li>
--   <li><tt> namespace-body </tt> is parsed by other parsers injected via
--   the ParserGraph</li>
--   </ul>
--   
--   See <a>https://alx71hub.github.io/hcb/#namespace.def</a> for more
--   context
namedNamespaceDefinition :: CppNamespace a => String -> ParserGraph a -> Parser a

-- | <pre>
--   unnamed-namespace-definition:	 
--    	inline (opt) namespace { namespace-body }
--   </pre>
--   
--   Notes:
--   
--   <ul>
--   <li><tt> original-namespace-name </tt> = <tt> identifier </tt></li>
--   <li><tt> namespace-body </tt> is parsed by other parsers injected via
--   the ParserGraph</li>
--   </ul>
--   
--   See <a>https://alx71hub.github.io/hcb/#namespace.def</a> for more
--   context
unnamedNamespaceDefinition :: CppNamespace a => String -> ParserGraph a -> Parser a

-- | BNF Grammar:
--   
--   <pre>
--   enum-specifier:	 
--    	enum-head { enumerator-list (opt) }
--    	enum-head { enumerator-list , }
--   </pre>
--   
--   Notes:
--   
--   <ul>
--   <li><tt> enumerator-list </tt> is parsed by other parsers injected via
--   the ParserGraph</li>
--   </ul>
--   
--   See <a>https://alx71hub.github.io/hcb/#dcl.enum</a> for more context
enumSpecifier :: CppEnum a => String -> ParserGraph a -> Parser a

-- | BNF Grammar:
--   
--   <pre>
--   enum-head:	 
--    	enum-key attribute-specifier-seq (opt) identifier (opt) enum-base (opt)
--    	enum-key attribute-specifier-seq (opt) nested-name-specifier identifier enum-base (opt)
--   </pre>
--   
--   See <a>https://alx71hub.github.io/hcb/#dcl.enum</a> for more context
enumHead :: Parser CppEnumHead

-- | BNF Grammar:
--   
--   <pre>
--   enum-key:	 
--    	enum
--    	enum class
--    	enum struct
--   </pre>
--   
--   See <a>https://alx71hub.github.io/hcb/#dcl.enum</a> for more context
enumKey :: Parser ()

-- | BNF Grammar:
--   
--   <pre>
--   enumerator-definition:	 
--    	enumerator
--    	enumerator = constant-expression
--   </pre>
--   
--   See <a>https://alx71hub.github.io/hcb/#dcl.enum</a> for more context
enumBase :: Parser [CppTypeSpecifier]
enumeratorDefinition :: CppEnumerator a => Parser a

-- | BNF Grammar:
--   
--   <pre>
--   class-specifier:	 
--    	class-head { member-specification (opt) }
--   </pre>
--   
--   Notes:
--   
--   <ul>
--   <li><tt> member-specification </tt> is parsed by other parsers
--   injected via the ParserGraph</li>
--   </ul>
--   
--   See <a>https://alx71hub.github.io/hcb/#class</a> for more context
classSpecifier :: CppClass a => String -> ParserGraph a -> Parser a

-- | BNF Grammar:
--   
--   <pre>
--   class-head:	 
--    	class-key attribute-specifier-seq (opt) class-head-name class-virt-specifier-seq (opt) base-clause (opt)
--    	class-key attribute-specifier-seq (opt) base-clause (opt)
--   </pre>
--   
--   See <a>https://alx71hub.github.io/hcb/#class</a> for more context
classHead :: Parser CppClassHead

-- | BNF Grammar:
--   
--   <pre>
--   class-key:	 
--    	class
--    	struct
--    	union
--   </pre>
--   
--   See <a>https://alx71hub.github.io/hcb/#class</a> for more context
classKey :: Parser ()

-- | BNF Grammar:
--   
--   <pre>
--   class-virt-specifier-seq:	 
--    	class-virt-specifier
--    	class-virt-specifier-seq class-virt-specifier  
--   </pre>
--   
--   Notes:
--   
--   <ul>
--   <li>Grammar for for <tt> class-virt-specifier-seq </tt> is recursive
--   and therfore can be sumarised to <tt> some ... </tt> in haskell</li>
--   </ul>
--   
--   See <a>https://alx71hub.github.io/hcb/#class</a> for more context
classVirtSpecifierSeq :: Parser [String]

-- | BNF Grammar:
--   
--   <pre>
--   class-virt-specifier:	 
--    	final
--   </pre>
--   
--   See <a>https://alx71hub.github.io/hcb/#class</a> for more context
classVirtSpecifier :: Parser String
baseClause :: Parser [CppBaseSpecifier]

-- | BNF Grammar:
--   
--   <pre>
--   base-specifier-list:	 
--    	base-specifier ... (opt)
--    	base-specifier-list , base-specifier ... (opt)
--   </pre>
--   
--   Notes:
--   
--   <ul>
--   <li>Grammar for for <tt> base-specifier-list </tt> is recursive and
--   therfore can be sumarised to <tt> some ... </tt> in haskell</li>
--   </ul>
--   
--   See <a>https://alx71hub.github.io/hcb/#class.derived</a> for more
--   context
baseSpecifierList :: Parser [CppBaseSpecifier]
baseSpecifier :: Parser CppBaseSpecifier

-- | BNF Grammar:
--   
--   <pre>
--   access-specifier:	 
--    	private
--    	protected
--    	public
--   </pre>
--   
--   See <a>https://alx71hub.github.io/hcb/#class.derived</a> for more
--   context
accessSpecifier :: Parser CppAccessSpecifier

-- | BNF Grammar:
--   
--   <pre>
--   class-or-decltype:	 
--    	:: (opt) nested-name-specifieropt class-name
--    	decltype-specifier
--   </pre>
--   
--   Notes:
--   
--   <ul>
--   <li>Currently <tt> decltype-specifier </tt> is not accepted as a valid
--   <tt> class-or-decltype </tt></li>
--   <li><b> TODO </b> : Support <tt> decltype-specifier </tt> as a valid
--   <tt> class-or-decltype </tt></li>
--   </ul>
--   
--   See <a>https://alx71hub.github.io/hcb/#class.derived</a> for more
--   context
classOrDeclType :: Parser String

-- | BNF Grammar:
--   
--   <pre>
--   class-name:	 
--    	identifier
--    	simple-template-id 
--   </pre>
--   
--   See <a>https://alx71hub.github.io/hcb/#class</a> for more context
className :: Parser String

-- | BNF Grammar:
--   
--   <pre>
--   attribute-specifier-seq:	 
--    	attribute-specifier
--    	attribute-specifier-seq attribute-specifier
--   </pre>
--   
--   Notes:
--   
--   <ul>
--   <li>Grammar for for <tt> attribute-specifier-seq </tt> is recursive
--   and therfore can be sumarised to <tt> some ... </tt> in haskell</li>
--   </ul>
--   
--   See <a>https://alx71hub.github.io/hcb/#dcl.attr.grammar</a> for more
--   context
attributeSpecifierSeq :: Parser [CppAttributeSpecifier]

-- | BNF Grammar:
--   
--   <pre>
--   attribute-specifier:	 
--    	[ [ attribute-list ] ]
--    	alignment-specifier
--   
--   alignment-specifier:	 
--    	alignas ( type-id ... (opt) )
--    	alignas ( assignment-expression ... (opt) )
--   </pre>
--   
--   Notes:
--   
--   <ul>
--   <li><tt> attribute-specifier </tt> is parsed as "token soup" (an array
--   of tokens, how you deal with this is up to you)</li>
--   </ul>
--   
--   See <a>https://alx71hub.github.io/hcb/#dcl.attr.grammar</a> for more
--   context
attributeSpecifier :: Parser CppAttributeSpecifier

-- | BNF Grammar:
--   
--   <pre>
--   type-specifier-seq:	 
--    	type-specifier attribute-specifier-seq (opt)
--    	type-specifier type-specifier-seq
--   </pre>
--   
--   Notes:
--   
--   <ul>
--   <li>Grammar for for <tt> type-specifier-seq </tt> is recursive and
--   therfore can be sumarised to <tt> some ... </tt> in haskell</li>
--   </ul>
--   
--   See <a>https://alx71hub.github.io/hcb/#dcl.type</a> for more context
typeSpecifierSeq :: Parser [CppTypeSpecifier]

-- | BNF Grammar:
--   
--   <pre>
--   type-specifier:	 
--    	trailing-type-specifier
--    	class-specifier
--    	enum-specifier
--   </pre>
--   
--   Notes:
--   
--   <ul>
--   <li>Currently <tt> class-specifier </tt> and <tt> enum-specifier </tt>
--   are not accepted as a valid <tt> type-specifier </tt></li>
--   <li><b> TODO </b> : Support <tt> class-specifier </tt> and <tt>
--   enum-specifier </tt> as a valid <tt> type-specifier </tt></li>
--   </ul>
--   
--   See <a>https://alx71hub.github.io/hcb/#dcl.type</a> for more context
typeSpecifier :: Parser String

-- | BNF Grammar:
--   
--   <pre>
--   trailing-type-specifier:	 
--    	simple-type-specifier
--    	elaborated-type-specifier
--    	typename-specifier
--    	cv-qualifier
--   </pre>
--   
--   Notes:
--   
--   <ul>
--   <li>Currently <tt> elaborated-type-specifier </tt> and <tt>
--   typename-specifier </tt> are not accepted as a valid <tt>
--   trailing-type-specifier </tt></li>
--   <li><b> TODO </b> : Support <tt> elaborated-type-specifier </tt> and
--   <tt> typename-specifier </tt> as a valid <tt> trailing-type-specifier
--   </tt></li>
--   </ul>
--   
--   See <a>https://alx71hub.github.io/hcb/#dcl.type</a> for more context
trailingTypeSpecifier :: Parser String

-- | BNF Grammar:
--   
--   <pre>
--   simple-type-specifier:	 
--    	:: (opt) nested-name-specifier (opt) type-name
--    	:: (opt) nested-name-specifier template simple-template-id
--    	char
--    	char16_t
--    	char32_t
--    	wchar_t
--    	bool
--    	short
--    	int
--    	long
--    	signed
--    	unsigned
--    	float
--    	double
--    	void
--    	auto
--    	decltype-specifier
--   </pre>
--   
--   Notes:
--   
--   <ul>
--   <li><tt> nested-name-specifier (opt) type-name </tt> is handled via
--   the function <tt> typeName </tt> <ul><li><tt> typeName </tt> uses the
--   function <tt> qualifiedName </tt> which internally implements <tt>
--   nested-name-specifier </tt> grammar</li></ul></li>
--   <li>Currently <tt> decltype-specifier </tt> is not accepted as a valid
--   <tt> trailing-type-specifier </tt></li>
--   <li><b> TODO </b> : Support <tt> decltype-specifie </tt> as a valid
--   <tt> simple-type-specifier </tt></li>
--   <li><b> TODO </b> : support optional preceeding <tt> :: </tt> for <tt>
--   :: (opt) nested-name-specifier (opt) type-name </tt> and <tt> :: (opt)
--   nested-name-specifier template simple-template-id </tt></li>
--   </ul>
--   
--   See <a>https://alx71hub.github.io/hcb/#dct.type.simple</a> for more
--   context
simpleTypeSpecifier :: Parser String

-- | BNF Grammar:
--   
--   <pre>
--   type-name:	 
--    	class-name
--    	enum-name
--    	typedef-name
--    	simple-template-id
--   </pre>
--   
--   Notes:
--   
--   <ul>
--   <li><tt> enum-name </tt> = <tt> identifier </tt>, <tt> typedef-name
--   </tt> = <tt> identifier </tt>, <tt> class-name </tt> = <tt> identifier
--   </tt> or <tt> simple-template-id </tt><ul><li>From this we can see
--   that a <tt> type-name </tt> is either an <tt> identifier </tt> or
--   simple <tt> template-id </tt></li><li>Everywhere <tt> type-name </tt>
--   occurs it is preceded by <tt> nested-name-specifier </tt> so lets just
--   use <tt> qualifiedName </tt> instead of <tt> identifier
--   </tt></li></ul></li>
--   </ul>
--   
--   See <a>https://alx71hub.github.io/hcb/#dct.type.simple</a> for more
--   contex
typeName :: Parser String

-- | BNF Grammar:
--   
--   <pre>
--   simple-template-id:	 
--    	template-name <a>(opt)</a>
--   </pre>
--   
--   Notes:
--   
--   <ul>
--   <li><tt> template-name </tt> = <tt> identifier </tt></li>
--   <li><tt> simple-template-id </tt> is parsed as a single string, for
--   example <tt> vector<a>int</a> </tt> will be parsed completely as <tt>
--   "vector<a>int</a>" </tt></li>
--   </ul>
--   
--   See <a>https://alx71hub.github.io/hcb/#dct.type.simple</a> for more
--   contex
simpleTemplateID :: Parser String

-- | BNF Grammar:
--   
--   <pre>
--   cv-qualifier:	 
--    	const
--    	volatile
--   </pre>
--   
--   See <a>https://alx71hub.github.io/hcb/#dcl.decl</a> for more contex
cvQualifier :: Parser String
simpleVariableDeclaration :: CppMemberVariable a => Parser a

module Lexer
lexicalAnalysis :: Set String -> String -> String -> Either (ParseErrorBundle String Void) [CppToken]
