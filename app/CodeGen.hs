{-# LANGUAGE OverloadedStrings #-}

module CodeGen where

import LexerTypes
import ParserTypes
import CodeGenTypes
import Data.List
import Data.Maybe
import Parser
import Util
import Text.Megaparsec
import Text.Megaparsec.Byte (lowerChar)
import Data.Char (toLower)
import Data.Aeson
import Data.Aeson.Encode.Pretty
import qualified Data.ByteString.Lazy.Char8 as BL

{- 
CppHeaderTool Code Generation Module

This module demonstrates how to:
1. Process the AST generated by the parser
2. Extract code generation attributes from C++ tokens
3. Generate C++ code for enum reflection
4. Generate JSON AST dumps for debugging

Key Concepts:
- flattenAst: Processes nested AST structure into a flat list
- qualifyExampleAstNode: Handles namespace qualification
- Attribute parsing: Extracts [[Reflected]], [[Serialized]], [[Default(...)]] attributes
- Code generation: Creates enum-to-string functions and reflection boilerplate
- JSON output: Serializes AST for debugging and analysis
-}

-------------------------------------------------------------------------------
-- AST PROCESSING
-------------------------------------------------------------------------------

-- | Flattens the AST structure for easier processing
-- Converts nested namespaces/classes/enums into a flat list with qualified names
flattenAst :: ExampleAstNode -> [ExampleAstNode]
flattenAst (HeaderNode xs) = concatMap flattenAst xs
flattenAst (NamespaceNode x xs) = concatMap (flattenAst . qualifyExampleAstNode x) xs
flattenAst (EnumNode x xs) = EnumNode x ys : concatMap (flattenAst . qualifyExampleAstNode (enumHeadName x)) ys'
    where (ys, ys') = partition excludeFromFlattening xs
flattenAst (ClassNode x xs) = ClassNode x ys : concatMap (flattenAst . qualifyExampleAstNode (classHeadName x)) ys'
    where (ys, ys') = partition excludeFromFlattening xs
flattenAst x = [x]

-- | Qualifies AST node names with parent namespace/class
qualifyExampleAstNode :: String -> ExampleAstNode -> ExampleAstNode
qualifyExampleAstNode parentName (NamespaceNode name children) =
    NamespaceNode (parentName ++ "::" ++ name) children
qualifyExampleAstNode parentName (EnumNode enumHead children) =
    EnumNode enumHead { enumHeadName = parentName ++ "::" ++ enumHeadName enumHead } children
qualifyExampleAstNode parentName (ClassNode classHead children) =
    ClassNode classHead { classHeadName = parentName ++ "::" ++ classHeadName classHead } children
qualifyExampleAstNode parentName (Enumerator name tokens) =
    Enumerator (parentName ++ "::" ++ name) tokens
qualifyExampleAstNode parentName (MemberVariable varDecl) =
    MemberVariable varDecl { variableName = parentName ++ "::" ++ variableName varDecl }
qualifyExampleAstNode _ node = node

-- | Determines which nodes should be excluded from flattening (kept as children)
excludeFromFlattening :: ExampleAstNode -> Bool
excludeFromFlattening (Enumerator _ _) = True      -- Enumerators stay with their enum
excludeFromFlattening (MemberVariable _) = True    -- Member variables stay with their class
excludeFromFlattening _ = False

-------------------------------------------------------------------------------
-- ATTRIBUTE PARSING
-------------------------------------------------------------------------------

-- | Parses the [[Reflected]] attribute
reflectedAttribute :: Parser CodeGenAttribute
reflectedAttribute = do
    _ <- matchIdentifier "Reflected"
    return Reflected

-- | Parses the [[Serialized]] attribute  
serializedAttribute :: Parser CodeGenAttribute
serializedAttribute = do
    _ <- matchIdentifier "Serialized"
    return Serialized

-- | Parses the [[Default("value")]] attribute
defaultAttribute :: Parser CodeGenAttribute
defaultAttribute = do
    _ <- matchIdentifier "Default"
    _ <- punctuator '('
    defaultValue <- identifier
    _ <- punctuator ')'
    return $ Default defaultValue

-- | Parses a single attribute specifier between [[ ]]
singleAttributeSpecifier :: Parser [CodeGenAttribute]
singleAttributeSpecifier = do
    _ <- chunk [Punctuator '[', Punctuator '[']
    applyParsersUntil' [reflectedAttribute, serializedAttribute, defaultAttribute] (chunk [Punctuator ']', Punctuator ']'])

-- | Parses multiple attribute specifiers using your robust applyParsersUntil'
multipleAttributeSpecifiers :: Parser [CodeGenAttribute]
multipleAttributeSpecifiers = do
    attributes <- applyParsersUntil' [singleAttributeSpecifier] eof
    return (concat attributes)

-- | Extracts code generation attributes from C++ tokens
getCodeGenAttributes :: [CppToken] -> [CodeGenAttribute]
getCodeGenAttributes tokens =
    case parse multipleAttributeSpecifiers "" tokens of
        Left _ -> []  -- Silently ignore parsing errors (no attributes present)
        Right attrs -> attrs

-- | Checks if a node has reflection attributes
hasReflectionAttributes :: [CodeGenAttribute] -> Bool
hasReflectionAttributes = any (\attr -> attr == Reflected || attr == Serialized)

-- | Checks if a node has serialization attributes  
hasSerializationAttributes :: [CodeGenAttribute] -> Bool
hasSerializationAttributes = (Serialized `elem`)

-- | Finds the default value in attributes (for enums)
findDefaultValue :: [CodeGenAttribute] -> Maybe String
findDefaultValue [] = Nothing
findDefaultValue (Default value : _) = Just value
findDefaultValue (_ : attrs) = findDefaultValue attrs

-------------------------------------------------------------------------------
-- C++ CODE GENERATION
-------------------------------------------------------------------------------

-- | Main code generation function - processes AST nodes and generates C++ code
generateCode :: [ExampleAstNode] -> String
generateCode astNodes =
    unlines $ generatedDisclaimer : filter (not . null) (map generateNodeCode astNodes)

-- | Generates code for a single AST node
generateNodeCode :: ExampleAstNode -> String
generateNodeCode (EnumNode enumHead children) =
    let attributes = getCodeGenAttributes (concat $ enumAttributeSpecifiers enumHead)
        enumName = enumHeadName enumHead
        baseType = unwords $ map typeSpecifierName (enumBaseClause enumHead)
    in unlines $ filter (not . null)
        [ fromMaybe "" (findDefaultValue attributes >>= \def ->
            Just $ generateEnumToStringFunctions enumName children def)
        , if hasReflectionAttributes attributes then
            generateReflectionBoilerplate enumName baseType
          else
            ""
        ]

generateNodeCode (ClassNode classHead children) =
    let attributes = getCodeGenAttributes (concat $ classAttributeSpecifiers classHead)
        enumName = classHeadName classHead
        baseType = unwords $ map baseTypeSpecifier (classBaseClause classHead)
    in if hasReflectionAttributes attributes then
            generateReflectionBoilerplate enumName baseType
        else
            ""

generateNodeCode _ = ""

-- | Generates enum to/from string conversion functions
generateEnumToStringFunctions :: String -> [ExampleAstNode] -> String -> String
generateEnumToStringFunctions enumName enumerators defaultEnumerator = unlines
    [ generateToStringFunction enumName enumerators
    , ""
    , generateFromStringFunction enumName enumerators defaultEnumerator
    ]

generateToStringFunction :: String -> [ExampleAstNode] -> String
generateToStringFunction enumName enumerators = unlines
    [ concat ["template<> inline std::string Util::ToString<", enumName, ">(", enumName, " value)"]
    , "{"
    , unlines (map (generateToStringCase enumName) enumerators)
    , "\treturn \"\";"
    , "}"
    ]

generateToStringCase :: String -> ExampleAstNode -> String
generateToStringCase enumName (Enumerator name _) = unlines
    [ concat ["\tif (value == ", enumName, "::", name, ")"]
    , concat ["\t\treturn \"", name, "\";"]
    ]
generateToStringCase _ _ = ""

generateFromStringFunction :: String -> [ExampleAstNode] -> String -> String
generateFromStringFunction enumName enumerators defaultEnumerator = unlines
    [ concat ["template<> inline ", enumName, " Util::FromString<", enumName, ">(std::string value)"]
    , "{"
    , unlines (map (generateFromStringCase enumName) enumerators)
    , concat ["\treturn ", enumName, "::", defaultEnumerator, ";"]
    , "}"
    ]

generateFromStringCase :: String -> ExampleAstNode -> String
generateFromStringCase enumName (Enumerator name _) = unlines
    [ concat ["\tif (value == \"", name, "\")"]
    , concat ["\t\treturn ", enumName, "::", name, ";"]
    ]
generateFromStringCase _ _ = ""

-- | Generates reflection system boilerplate code
generateReflectionBoilerplate :: String -> String -> String
generateReflectionBoilerplate className parentName = unlines
    [ concat ["template<> inline std::string Util::GetClassName<", className, ">() { return \"", className, "\"; }"]
    , ""
    , concat ["template<> inline std::string Util::GetParentClassName<", className, ">() { return \"", parentName, "\"; }"]
    ]

-------------------------------------------------------------------------------
-- JSON AST DUMP GENERATION
-------------------------------------------------------------------------------

-- | Generates JSON representation of the AST for debugging
generateJSON :: [ExampleAstNode] -> String
generateJSON = BL.unpack . encodePretty--unlines $ filter (not . null) (map generateNodeJSON astNodes)

-- | Generates JSON for a single AST node
instance ToJSON ExampleAstNode where
    toJSON (ClassNode classHead children) =
        object
            [ "astNodeType" .= String "class"
            , "name" .= classHeadName classHead
            , "parent" .= unwords (map baseTypeSpecifier (classBaseClause classHead))
            , "children" .= children
            , "isReflected" .= hasReflectionAttributes attributes
            , "isSerialized" .= hasSerializationAttributes attributes
            ]
      where
        attributes = getCodeGenAttributes (concat $ classAttributeSpecifiers classHead)

    toJSON (EnumNode enumHead children) =
        object
            [ "astNodeType" .= String "enum"
            , "name" .= enumHeadName enumHead
            , "parent" .= unwords (map typeSpecifierName (enumBaseClause enumHead))
            , "children" .= children
            , "isReflected" .= hasReflectionAttributes attributes
            , "isSerialized" .= hasSerializationAttributes attributes
            , "default" .= fromMaybe "" (findDefaultValue attributes)
            ]
      where
        attributes = getCodeGenAttributes (concat $ enumAttributeSpecifiers enumHead)

    toJSON (MemberVariable varDecl) =
        object
            [ "astNodeType" .= String "memberVariable"
            , "name" .= variableName varDecl
            , "type" .= variableType varDecl
            ]

    toJSON (Enumerator name _) =
        object
            [ "astNodeType" .= String "enumerator"
            , "name" .= name
            ]
-------------------------------------------------------------------------------
-- UTILITIES
-------------------------------------------------------------------------------

generatedDisclaimer :: String
generatedDisclaimer = "// Code Generated By CppHeaderTool - https://github.com/yourusername/CppHeaderTool"