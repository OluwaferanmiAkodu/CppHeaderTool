module CodeGen where

import LexerTypes
import ParserTypes
import CodeGenTypes
import Data.List
import Data.Maybe
import Parser
import Util
import Text.Megaparsec
import Text.Megaparsec.Byte (lowerChar)
import Data.Char (toLower)

{- 
CppHeaderTool Code Generation Module

This module demonstrates how to:
1. Process the AST generated by the parser
2. Extract code generation attributes from C++ tokens
3. Generate C++ code for enum reflection
4. Generate JSON AST dumps for debugging

Key Concepts:
- flattenAst: Processes nested AST structure into a flat list
- qualifyExampleAstNode: Handles namespace qualification
- Attribute parsing: Extracts [[Reflected]], [[Serialized]], [[Default(...)]] attributes
- Code generation: Creates enum-to-string functions and reflection boilerplate
- JSON output: Serializes AST for debugging and analysis
-}

-------------------------------------------------------------------------------
-- AST PROCESSING
-------------------------------------------------------------------------------

-- | Flattens the AST structure for easier processing
-- Converts nested namespaces/classes/enums into a flat list with qualified names
flattenAst :: ExampleAstNode -> [ExampleAstNode]
flattenAst (HeaderNode xs) = concatMap flattenAst xs
flattenAst (NamespaceNode x xs) = concatMap (flattenAst . qualifyExampleAstNode x) xs
flattenAst (EnumNode x xs) = EnumNode x ys : concatMap (flattenAst . qualifyExampleAstNode (enumHeadName x)) ys'
    where (ys, ys') = partition excludeFromFlattening xs
flattenAst (ClassNode x xs) = ClassNode x ys : concatMap (flattenAst . qualifyExampleAstNode (classHeadName x)) ys'
    where (ys, ys') = partition excludeFromFlattening xs
flattenAst x = [x]

-- | Qualifies AST node names with parent namespace/class
qualifyExampleAstNode :: String -> ExampleAstNode -> ExampleAstNode
qualifyExampleAstNode parentName (NamespaceNode name children) =
    NamespaceNode (parentName ++ "::" ++ name) children
qualifyExampleAstNode parentName (EnumNode enumHead children) =
    EnumNode enumHead { enumHeadName = parentName ++ "::" ++ enumHeadName enumHead } children
qualifyExampleAstNode parentName (ClassNode classHead children) =
    ClassNode classHead { classHeadName = parentName ++ "::" ++ classHeadName classHead } children
qualifyExampleAstNode parentName (Enumerator name tokens) =
    Enumerator (parentName ++ "::" ++ name) tokens
qualifyExampleAstNode parentName (MemberVariable varDecl) =
    MemberVariable varDecl { variableName = parentName ++ "::" ++ variableName varDecl }
qualifyExampleAstNode _ node = node

-- | Determines which nodes should be excluded from flattening (kept as children)
excludeFromFlattening :: ExampleAstNode -> Bool
excludeFromFlattening (Enumerator _ _) = True      -- Enumerators stay with their enum
excludeFromFlattening (MemberVariable _) = True    -- Member variables stay with their class
excludeFromFlattening _ = False

-------------------------------------------------------------------------------
-- ATTRIBUTE PARSING
-------------------------------------------------------------------------------

-- | Parses the [[Reflected]] attribute
reflectedAttribute :: Parser CodeGenAttribute
reflectedAttribute = do
    _ <- matchIdentifier "Reflected"
    return Reflected

-- | Parses the [[Serialized]] attribute  
serializedAttribute :: Parser CodeGenAttribute
serializedAttribute = do
    _ <- matchIdentifier "Serialized"
    return Serialized

-- | Parses the [[Default("value")]] attribute
defaultAttribute :: Parser CodeGenAttribute
defaultAttribute = do
    _ <- matchIdentifier "Default"
    _ <- punctuator '('
    defaultValue <- identifier
    _ <- punctuator ')'
    return $ Default defaultValue

-- | Parses a single attribute specifier between [[ ]]
singleAttributeSpecifier :: Parser [CodeGenAttribute]
singleAttributeSpecifier = do
    _ <- chunk [Punctuator '[', Punctuator '[']
    applyParsersUntil' [reflectedAttribute, serializedAttribute, defaultAttribute] (chunk [Punctuator ']', Punctuator ']'])

-- | Parses multiple attribute specifiers using your robust applyParsersUntil'
multipleAttributeSpecifiers :: Parser [CodeGenAttribute]
multipleAttributeSpecifiers = do
    attributes <- applyParsersUntil' [singleAttributeSpecifier] eof
    return (concat attributes)

-- | Extracts code generation attributes from C++ tokens
getCodeGenAttributes :: [CppToken] -> [CodeGenAttribute]
getCodeGenAttributes tokens =
    case parse multipleAttributeSpecifiers "" tokens of
        Left _ -> []  -- Silently ignore parsing errors (no attributes present)
        Right attrs -> attrs

-- | Checks if a node has reflection attributes
hasReflectionAttributes :: [CodeGenAttribute] -> Bool
hasReflectionAttributes = any (\attr -> attr == Reflected || attr == Serialized)

-- | Checks if a node has serialization attributes  
hasSerializationAttributes :: [CodeGenAttribute] -> Bool
hasSerializationAttributes = (Serialized `elem`)

-- | Finds the default value in attributes (for enums)
findDefaultValue :: [CodeGenAttribute] -> Maybe String
findDefaultValue [] = Nothing
findDefaultValue (Default value : _) = Just value
findDefaultValue (_ : attrs) = findDefaultValue attrs

-------------------------------------------------------------------------------
-- C++ CODE GENERATION
-------------------------------------------------------------------------------

-- | Main code generation function - processes AST nodes and generates C++ code
generateCode :: [ExampleAstNode] -> String
generateCode astNodes =
    unlines $ generatedDisclaimer : filter (not . null) (map generateNodeCode astNodes)

-- | Generates code for a single AST node
generateNodeCode :: ExampleAstNode -> String
generateNodeCode (EnumNode enumHead children) =
    let attributes = getCodeGenAttributes (concat $ enumAttributeSpecifiers enumHead)
        enumName = enumHeadName enumHead
        baseType = unwords $ map typeSpecifierName (enumBaseClause enumHead)
    in unlines $ filter (not . null)
        [ fromMaybe "" (findDefaultValue attributes >>= \def ->
            Just $ generateEnumToStringFunctions enumName children def)
        , if hasReflectionAttributes attributes then
            generateReflectionBoilerplate enumName baseType
          else
            ""
        ]
generateNodeCode _ = ""

-- | Generates enum to/from string conversion functions
generateEnumToStringFunctions :: String -> [ExampleAstNode] -> String -> String
generateEnumToStringFunctions enumName enumerators defaultEnumerator = unlines
    [ generateToStringFunction enumName enumerators
    , ""
    , generateFromStringFunction enumName enumerators defaultEnumerator
    ]

generateToStringFunction :: String -> [ExampleAstNode] -> String
generateToStringFunction enumName enumerators = unlines
    [ concat ["template<> inline std::string Util::ToString<", enumName, ">(", enumName, " value)"]
    , "{"
    , unlines (map (generateToStringCase enumName) enumerators)
    , "\treturn \"\";"
    , "}"
    ]

generateToStringCase :: String -> ExampleAstNode -> String
generateToStringCase enumName (Enumerator name _) = unlines
    [ concat ["\tif (value == ", enumName, "::", name, ")"]
    , concat ["\t\treturn \"", name, "\";"]
    ]
generateToStringCase _ _ = ""

generateFromStringFunction :: String -> [ExampleAstNode] -> String -> String
generateFromStringFunction enumName enumerators defaultEnumerator = unlines
    [ concat ["template<> inline ", enumName, " Util::FromString<", enumName, ">(std::string value)"]
    , "{"
    , unlines (map (generateFromStringCase enumName) enumerators)
    , concat ["\treturn ", enumName, "::", defaultEnumerator, ";"]
    , "}"
    ]

generateFromStringCase :: String -> ExampleAstNode -> String
generateFromStringCase enumName (Enumerator name _) = unlines
    [ concat ["\tif (value == \"", name, "\")"]
    , concat ["\t\treturn ", enumName, "::", name, ";"]
    ]
generateFromStringCase _ _ = ""

-- | Generates reflection system boilerplate code
generateReflectionBoilerplate :: String -> String -> String
generateReflectionBoilerplate className parentName = unlines
    [ concat ["template<> inline std::string Util::GetClassName<", className, ">() { return \"", className, "\"; }"]
    , ""
    , concat ["template<> inline std::string Util::GetParentClassName<", className, ">() { return \"", parentName, "\"; }"]
    ]

-------------------------------------------------------------------------------
-- JSON AST DUMP GENERATION
-------------------------------------------------------------------------------

-- | Generates JSON representation of the AST for debugging
generateJSON :: [ExampleAstNode] -> String
generateJSON astNodes = unlines $ filter (not . null) (map generateNodeJSON astNodes)

-- | Generates JSON for a single AST node
generateNodeJSON :: ExampleAstNode -> String
generateNodeJSON (ClassNode classHead children) = generateClassJSON classHead children
generateNodeJSON (EnumNode enumHead children) = generateEnumJSON enumHead children
generateNodeJSON (MemberVariable varDecl) = generateMemberVariableJSON varDecl
generateNodeJSON (Enumerator name _) = generateEnumeratorJSON name
generateNodeJSON _ = "{}"

generateClassJSON :: CppClassHead -> [ExampleAstNode] -> String
generateClassJSON classHead children = unlines
    [ "{"
    , "\t\"astNodeType\": \"class\","
    , concat ["\t\"name\": \"", classHeadName classHead, "\","]
    , "\t\"children\": ["
    , intercalate ",\n" (map (indentJSON 2 . generateNodeJSON) children)
    , "\t],"
    , concat ["\t\"isReflected\": ", map toLower (show $ hasReflectionAttributes attributes), ","]
    , "\t\"isSerialized\": " ++ map toLower (show $ hasSerializationAttributes attributes)
    , "}"
    ]
    where attributes = getCodeGenAttributes (concat $ classAttributeSpecifiers classHead)

generateEnumJSON :: CppEnumHead -> [ExampleAstNode] -> String
generateEnumJSON enumHead children = unlines
    [ "{"
    , "\t\"astNodeType\": \"enum\","
    , concat ["\t\"name\": \"", enumHeadName enumHead, "\","]
    , "\t\"children\": ["
    , intercalate ",\n" (map (indentJSON 2 . generateNodeJSON) children)
    , "\t],"
    , concat ["\t\"isReflected\": ", map toLower (show $ hasReflectionAttributes attributes), ","]
    , concat ["\t\"isSerialized\": ", map toLower (show $ hasSerializationAttributes attributes), ","]
    , case findDefaultValue attributes of
        Just def -> concat ["\t\"default\": \"", def, "\""]
        Nothing -> "\t\"default\": null"
    , "}"
    ]
    where attributes = getCodeGenAttributes (concat $ enumAttributeSpecifiers enumHead)

generateMemberVariableJSON :: CppVariableDeclaration -> String
generateMemberVariableJSON varDecl = unlines
    [ "{"
    , "\t\"astNodeType\": \"memberVariable\","
    , concat ["\t\"name\": \"", variableName varDecl, "\","]
    , concat ["\t\"type\": \"", variableType varDecl, "\""]
    , "}"
    ]

generateEnumeratorJSON :: String -> String
generateEnumeratorJSON name = unlines
    [ "{"
    , "\t\"astNodeType\": \"enumerator\","
    , concat ["\t\"name\": \"", name, "\""]
    , "}"
    ]

-- | Helper to indent JSON output
indentJSON :: Int -> String -> String
indentJSON levels json = unlines $ map (replicate (levels * 4) ' ' ++) (lines json)

-------------------------------------------------------------------------------
-- UTILITIES
-------------------------------------------------------------------------------

generatedDisclaimer :: String
generatedDisclaimer = "// Code Generated By CppHeaderTool - https://github.com/yourusername/CppHeaderTool"